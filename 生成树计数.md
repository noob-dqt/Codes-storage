### 图论：生成树计数
给出一个由 n 个点和 m 条边构成的简单无向加权图，有时需要对生成树计数或对最小生成树计数。
生成树计数利用基尔霍夫矩阵的 Matrix-Tree 定理即可计算
最小生成树计数时，根据数据范围采用不同方法

#### 1.生成树计数
对于给定图，先计算基尔霍夫矩阵K：
统计度数矩阵D[G]：当 i≠j 时，D[i][j]=0，当 i=j 时，D[i][i]= 节点vi的度数
统计邻接矩阵 A[G]：当 vi到vj有边A[i][j]=A[j][i]=1否则A[i][j]=0
有K[i][j]=D[i][j]-A[i][j]

K的性质（对于图 G）：

    1.K 的每一行或每一列上的元素和都是 0
    2.K 的行列式的值为 0
    3.K 的任意一个代数余子式值都相同
    4.如果图 G 不连通，基尔霍夫矩阵 K 的任意主子式行列式值为 0
    5.如果图 G 是一棵树，基尔霍夫矩阵 K 的任意一个 n-1 阶主子式的行列式为 1

Matrix-Tree定理：对于基尔霍夫矩阵K，去掉其随意一行一列得出的矩阵的行列式的绝对值为该图对应的生成树的个数
模板代码：
```cpp
LL K[N][N];
LL gauss(int n){//求矩阵K的n-1阶顺序主子式
    LL res=1;
    //转换成上/下三角，对角线元素值乘积为结果
    //如果在模意义下需要用辗转相除法完成消元过程
    for(int i=1;i<=n-1;i++){//枚举主对角线上第i个元素
        for(int j=i+1;j<=n-1;j++){//枚举剩下的行
            while(K[j][i]){//辗转相除
                int t=K[i][i]/K[j][i];
                for(int k=i;k<=n-1;k++)//转为倒三角
                    K[i][k]=(K[i][k]-t*K[j][k]+MOD)%MOD;
                swap(K[i],K[j]);//交换i、j两行
                res=-res;//取负
            }
        }
        res=(res*K[i][i])%MOD;
    }
    return (res+MOD)%MOD;
}
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    memset(K,0,sizeof(K));
    for(int i=1;i<=m;i++){
        int x,y;
        scanf("%d%d",&x,&y);
        K[x][x]++; //对应节点xy的度数加一
        K[y][y]++;
        K[x][y]--; //对应于度数矩阵减邻接矩阵的操作
        K[y][x]--;
    }
    printf("%lld\n",gauss(n));
    return 0;
}
```